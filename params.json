{"name":"Coreos","tagline":"How to setup a CoreOS cluster along with some useful bells and whistles","body":"### Summary\r\n* Setup 3 node CoreOS cluster via Cloud Formation fronted by an ELB\r\n* Deploy monitoring and logging containers\r\n* Deploy http server container\r\n* Setup .bit domain\r\n* Add automated build, test and deploy\r\n\r\n### Setup Docker\r\nAssuming you are on OSX here.\r\n* [Install](https://www.virtualbox.org/) virtualbox, it's needed by boot2docker.\r\n* [Install](https://www.vagrantup.com/downloads) vagrant.  While not strictly necessary it comes in handy if you want to create local clusters on your workstation instead of EC2.\r\n* [Install](https://docs.docker.com/installation/mac/) docker, or rather boot2docker, if you're on OSX.\r\n* [Create an account](https://hub.docker.com/) on dockerhub.\r\n\r\n\r\n### Setup AWS\r\n* [Create an account](https://aws.amazon.com/) with Amazon AWS.  You will have to pay for your usage.  A single CoreOS cluster with an ELB is costing me about $3 a day.\r\n* Add an account via [IAM](https://aws.amazon.com/iam/).\r\n* Generate an SSH keypair locally and upload the public key, or upload your existing public key:\r\n```\r\nssh-keygen -t rsa -f id_rsa\r\n```\r\n\r\n* [Install](http://docs.aws.amazon.com/cli/latest/userguide/cli-chap-getting-set-up.html) the AWS command line tools:\r\n```\r\nwget https://s3.amazonaws.com/aws-cli/awscli-bundle.zip\r\nunzip awscli-bundle.zip\r\nsudo ./awscli-bundle/install -i /usr/local/aws -b /usr/local/bin/aws\r\n```\r\n\r\nAdd necessary environment variables to your ~/.bash_profile:\r\n```\r\n# AWS creds\r\nexport AWS_ACCESS_KEY_ID=XXXXXXXXXXXXXX\r\nexport AWS_SECRET_ACCESS_KEY=XXXXXXXXXXXXXXXXXXXXXX\r\nexport AWS_DEFAULT_REGION=us-west-1\r\nexport AWS_DEFAULT_OUTPUT=text\r\n```\r\n\r\n### Launch Cloud Formation Stack\r\nUsing the template provided from CoreOS, add your own parameters and fire up [Cloud Formation](http://docs.aws.amazon.com/cli/latest/reference/cloudformation/create-stack.html).\r\n\r\nDon’t forget to [generate](https://discovery.etcd.io/new) a new DiscoveryURL.\r\nThe following parameters are passed to the template, in case you want to change them\r\n* DiscoveryURL: used by etcd to initialize the cluster by discovering peers.\r\n* InstanceType: EC2 instance type.  I found t2.small to be about as small as I could get with reasonable performance.\r\n* KeyPair: the name of the SSH keypair you uploaded to AWS\r\n\r\nThe template sets the following defaults.  If you want something else, [other templates](https://coreos.com/docs/running-coreos/cloud-providers/ec2/) are available from CoreOS.\r\n* CoreOS channel: alpha\r\n* PV vs HVM: HVM\r\n* Region: us-west-1\r\n\r\n```\r\naws cloudformation create-stack --stack-name CoreOS-alpha --template-url https://s3.amazonaws.com/coreos.com/dist/aws/coreos-alpha-hvm.template --parameters ParameterKey=DiscoveryURL,ParameterValue=https://discovery.etcd.io/0ffffffffffffffffffffffffffff,UsePreviousValue=true ParameterKey=InstanceType,ParameterValue=t2.small,UsePreviousValue=true ParameterKey=KeyPair,ParameterValue=daniel,UsePreviousValue=true\r\n```\r\n\r\nWatch the magic happen in your AWS web console.  Once created, adjust ASG Max instances to 3 (to prevent ballooning resource use).\r\n\r\n### Verify connectivity\r\nLet's login and [explore the cluster](https://coreos.com/docs/launching-containers/launching/fleet-using-the-client/#exploring-the-cluster) a little.\r\n\r\nGet the public IPs of the instances:\r\n```\r\naws ec2 describe-instances --filter Name=tag:Name,Values=CoreOS-alpha | grep ASSOCIATION | sort | uniq | awk '{print $NF}'\r\n111.111.111.200\r\n111.111.111.201\r\n111.111.111.202\r\n```\r\n\r\nSSH to the public IP of each instance, test fleet and etcd.  fleetctl communicates over SSH so using ‘-A' allows for forwarding ssh connections, useful for when running fleetctl on the hosts.\r\n```\r\nssh -A core@111.111.111.200\r\nfleetctl list-machines\r\netcdctl ls\r\n```\r\n\r\n[Download](https://github.com/coreos/fleet/releases) fleetctl to local workstation\r\n\r\nLoad your private key into ssh-agent (needed to make remote fleetctl work as it operates over SSH):\r\n```\r\nssh-add ~/.ssh/id_rsa\r\nssh-add -l\r\n```\r\n\r\nAdd IP of one of the machines to local ~/.bash_profile for remote comms:\r\n```\r\n# Connect to remote CoreOS on EC2\r\nexport FLEETCTL_TUNNEL=111.111.111.200:22\r\n```\r\n\r\nsource and verify:\r\n```\r\n.~/.bash_profile\r\nfleetctl list-machines\r\n```\r\n\r\n### Upload and start DataDog monitoring service\r\nDocs:\r\nhttps://www.datadoghq.com/2014/08/monitor-coreos-scale-datadog/\r\nhttps://www.datadoghq.com/2014/06/docker-ize-datadog/\r\n\r\n[Sign up](https://www.datadoghq.com/) for datadog.  It’s free.\r\n\r\nPut your personal API key into etcd (run from any host):\r\n```\r\netcdctl set /ddapikey XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\r\n```\r\n\r\nFork danielnbarbosa/docker-dd-agent github repo via the web UI\r\n\r\nReplace my dockerhub id with your own:\r\n```\r\nsed -i -e 's/danielnbarbosa/YOUR_DOCKERHUB_ID/g'\r\n```\r\n\r\nUpload and start fleet units:\r\n```\r\nfleetctl submit dd-agent@.service\r\nfleetctl start dd-agent@{1..3}.service\r\n```\r\n\r\nVerify metrics are flowing in the DataDog web UI.\r\n\r\n### Upload and start Loggly log service\r\nDocs:\r\nhttps://www.loggly.com/blog/centralize-logs-docker-containers/\r\nhttps://www.loggly.com/docs/docker-syslog/\r\n\r\n[Sign up](https://www.loggly.com/) for loggly.  Also free.\r\n\r\nPut your personal API key into etcd (run from any host):\r\n```\r\netcdctl set /logapikey XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\r\n```\r\n\r\nFork danielnbarbosa/docker-loggly-agent github repo via the web UI.\r\n\r\nReplace my dockerhub id with your own:\r\n```\r\nsed -i -e 's/danielnbarbosa/YOUR_DOCKERHUB_ID/g' *\r\n```\r\n\r\nUpload and start fleet units:\r\n```\r\nfleetctl submit loggly-agent@.service\r\nfleetctl start loggly-agent@{1..3}.service\r\n```\r\n\r\nRest logging from each host, substitute UDP port (49153) as appropriate:\r\n```\r\necho netcat:\"Host test log\" | ncat -u -w 1 127.0.0.1 49153\r\n```\r\n\r\nVerify logs are flowing at loggly.com\r\n\r\n\r\n### Create ELB\r\nGet your default VPC security group:\r\n```\r\naws ec2 describe-security-groups | grep SECURITYGROUPS | grep default | awk '{print $6}'\r\n```\r\n\r\nCreate the ELB:\r\n```\r\naws elb create-load-balancer --load-balancer-name=lb-coreos-alpha --listeners Protocol=HTTP,LoadBalancerPort=80,InstanceProtocol=HTTP,InstancePort=80 --availability-zones us-west-1a us-west-1b --security-groups=sg-111aaa5c\r\n```\r\n\r\nAdd the 3 instances:\r\n```\r\naws ec2 describe-instances --filter Name=tag:Name,Values=CoreOS-stable | grep INSTANCES | awk '{print $8}'\r\ni-8e1111d1\r\ni-8e1111d2\r\ni-8e1111d3\r\n```\r\n\r\nRegister instances with ELB:\r\naws elb register-instances-with-load-balancer --load-balancer-name lb-coreos-alpha --instances i-8e1111d1i-8e1111d2i-8e1111d3\r\n\r\nDrop healthy threshold to 2 (so it doesn’t take so long for an instance to be brought in service).  Note that the ELB will remain out of service until we deploy the http container.\r\n\r\n\r\n### Configure CoreOS cluster security groups\r\nAllow all TCP ports (0-65535) internal to CoreOS security group (will make debugging easier)\r\nAllow all TCP ports (0-65535) from default VPC (for the ELB and testing various services)\r\n\r\n### Upload and start noke.bit http service\r\n\r\nFork danielnbarbosa/docker-noke-nginx repo via the web UI\r\n\r\nReplace my dockerhub id with your own:\r\n```\r\nsed -i -e 's/danielnbarbosa/YOUR_DOCKERHUB_ID/g'\r\n```\r\n\r\nUpload and start fleet units:\r\n```\r\nfleetctl submit noke-nginx@.service\r\nfleetctl start noke-nginx@{1..3}.service\r\n```\r\n\r\n### setup DNS\r\n* register noke.bit domain in route53\r\n* point root A record alias to ELB\r\n\r\n\r\n### register domain name\r\nDocs:\r\nhttp://dot-bit.org/HowToRegisterAndConfigureBitDomains\r\n\r\n[Download](https://github.com/namecoin/namecoin) namecoind\r\n\r\nBuild and compile and sync the blockchain.  It will take a while to first sync the blockchain.\r\n\r\nBuy some namecoin.  This is a bit complicated.  You’ll first need to buy some bitcoin and then find and exchange that will sell you namecoin for bitcoin.  Once you have the namecoin you can use your local namecoind to register a .bit domain (paying a small fee in namecoin for spam prevention).\r\n\r\n[Register and update](http://dot-bit.org/HowToRegisterAndConfigureBitDomains) namecoin blockchain with new NS data.  You won't be able to use noke cause that's mine :).\r\n```\r\nnamecoind name_update d/noke '{\"ns\": [\"ns-389.awsdns-48.com\", \"ns-776.awsdns-33.net\", \"ns-1125.awsdns-12.org\", \"ns-1695.awsdns-19.co.uk\"]}'\r\n```\r\nDon’t forget to restart chrome in case the plugin has locally cached your domain.  Alternatively you can just hack your local hosts file or resolv.conf.\r\n\r\n\r\n### Rebalance btrfs\r\nbtrfs is the default filesystem used by docker.  On all hosts you'll need to rebalance btrfs to prevent running out of filesystem space.  This is something that has to be done regularly to prevent btrfs from filling up (especially on these t2.smalls).\r\n```\r\nbtrfs filesystem df /; sudo btrfs balance start /; btrfs filesystem df /\r\n```\r\n\r\n\r\n### integrate Circle CI\r\n[Sign up](https://circleci.com/) for Circle CI\r\n\r\nGenerate a new SSH keypair locally for circleCI to use to access the hosts:\r\n```\r\nssh-keygen -t rsa -f id_circleci\r\n```\r\n\r\nAdd public key to ec2 instances:\r\n```\r\ncat ~/.ssh/id_circleci.pub\r\n```\r\non each host:\r\n```\r\nvi ~/.ssh/authorized_keys\r\n```\r\n\r\nfor each of the docker repos you forked:\r\n  and project and follow repo in circle CI\r\n  add dockerhub env vars to circeCI project:\r\n```\r\n    cat ~/.dockercfg\r\n    DOCKER_EMAIL=XXXXXXXXXXXX\r\n    DOCKER_AUTH=XXXXXXXXXXXXX\r\n```\r\n  add private key (generated earlier) to circleCI project\r\n\r\ntest standard build and deploy (dd-agent, loggly-agent):\r\nmodify a file in the repo (like the IP address hardcoded into deploy.sh):\r\n```\r\ngit add .\r\ngit commit -m “testing circleci\"\r\ngit push\r\n```\r\nneed to set upstream?\r\nwatch circleCI build and deploy the container\r\n\r\ntest build with rolling deploy (noke-nginx):\r\nmodify a file in the repo (like the IP address hardcoded into deploy.sh)\r\n```\r\ngit add .\r\ngit commit -m “testing circleci\"\r\ngit push\r\n```\r\nwatch circleCI build and deploy the container without taking the site down.  sweet!\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}